== TriMesh ==
See header for details on what this object is.
The comments here will concern implementation details.

Notes:
http://www.cs.washington.edu/education/courses/cse457/07sp/lectures/triangle_intersection.pdf

== Add vertex ==
-
void TriMesh::AddVertex(float x, float y, float z) {
  _vertices.push_back(glm::vec3(x, y, z));
  Rebuild bounding box.
}
-

== Add triangle ==
-
void TriMesh::AddTriangle(int v1, int v2, int v3) {
  _triangles.push_back(glm::vec3(v1, v2, v3));
}
-

== Rebuild bounding box ==
When a new triangle is added to a trimesh, we need
to rebuild the bounding box.
-
glm::vec3 min = _vertices[0];
glm::vec3 max = _vertices[0];
for (int i = 0; i < _vertices.size(); ++i) {
  if (_vertices[i][0] < min[0]) { min[0] = _vertices[i][0]; }
  if (_vertices[i][1] < min[1]) { min[1] = _vertices[i][1]; }
  if (_vertices[i][2] < min[2]) { min[2] = _vertices[i][2]; }
  if (_vertices[i][0] > max[0]) { max[0] = _vertices[i][0]; }
  if (_vertices[i][1] > max[1]) { max[1] = _vertices[i][1]; }
  if (_vertices[i][2] > max[2]) { max[2] = _vertices[i][2]; }
  _bb = new BoundingBox(min, max);
}
-

== Intersection ==
Loop through all triangles and determine if
the ray hits the plane they lie in.
If so, then determine if the ray hit inside
the triangle.
Return intersection point and normal information.
-
Intersection* TriMesh::Intersects(Ray ray, float t_max) {
  Apply inverse transforms to ray.
  Check if ray intersects with bounding box.
  Intersection* intersection = NULL;
  for(std::vector<glm::vec3>::iterator itr = _triangles.begin(); itr != _triangles.end(); ++itr) {
    glm::vec3 tri = *itr;
    Calculate vertices and norm.
    Determine if ray hit plane.
    Determine if ray intersection inside triangle.
  }
  return intersection;
}
-

== Apply inverse transforms to ray ==
-
glm::vec4 homoRayOrigin = glm::vec4(ray.GetOrigin(), 1.f) * _inverseTransform;
glm::vec4 homoRayDirection = glm::vec4(ray.GetDirection(), 0.f) * _inverseTransform;
glm::vec3 rayOrigin = glm::vec3(homoRayOrigin[0], homoRayOrigin[1], homoRayOrigin[2]);
glm::vec3 rayDirection = glm::vec3(homoRayDirection[0], homoRayDirection[1], homoRayDirection[2]);
-

== Check if ray intersects with bounding box ==
-
if (!_bb->Intersect(rayOrigin, rayDirection, t_max)) { return NULL; }
-

== Calculate vertices and norm ==
-
glm::vec3 v1 = _vertices[tri[0]];
glm::vec3 v2 = _vertices[tri[1]];
glm::vec3 v3 = _vertices[tri[2]];

glm::vec3 norm = glm::normalize(glm::cross(v2 - v1, v3 - v1));
-

== Determine if ray hit plane ==
If t below is 0, then the ray is parallel to the surface.
If t is negative, the intersection occurred from behind the
ray's origin, so should be ignored.
If t is over t_max, it should also be ignored.
-
if (glm::dot(rayDirection, norm) == 0) { break; }
float t = glm::dot(v1 - rayOrigin, norm) / glm::dot(rayDirection, norm);
if (t < EPSILON || t > t_max) { break; }
//Debug details of triangle.
-

== Debug details of triangle ==
-
std::cout << "triangle: " << std::endl;
std::cout << "\tv1: [" << v1[0] << ", " << v1[1] << ", " << v1[2] << "]" << std::endl;
std::cout << "\tv2: [" << v2[0] << ", " << v2[1] << ", " << v2[2] << "]" << std::endl;
std::cout << "\tv3: [" << v3[0] << ", " << v3[1] << ", " << v3[2] << "]" << std::endl;
std::cout << "\tIntersected trimesh at t: " << t << std::endl;
std::cout << "\tt_max set to: " << t_max << std::endl;
std::cout << "\tnorm: [" << norm[0] << ", " << norm[1] << ", " << norm[2] << "]" << std::endl;
-

== Determine if ray intersection inside triangle ==
This assumes triangles with a counter-clockwise winding.
Reverse the subtractions for clockwise winding.
-
glm::vec3 intersectionPoint = rayOrigin + (rayDirection * t);
if (
  glm::dot(glm::cross(v2 - v1, intersectionPoint - v1), norm) >= 0.f &&
  glm::dot(glm::cross(v3 - v2, intersectionPoint - v2), norm) >= 0.f &&
  glm::dot(glm::cross(v1 - v3, intersectionPoint - v3), norm) >= 0.f
) {
  Apply transform to intersection point.
  Apply inverse transform to norm.
  intersection = new Intersection(ray, intersectionPoint, t, norm);
  //std::cout << "\tfound valid intersection at t: " << t << std::endl;
  break;
} else {
  //std::cout << "\tintersection on plane, but not inside triangle. intersection at t: " << t << std::endl;
}
-

== Apply transform to intersection point ==
-
glm::vec4 homoIntersectionPoint = glm::vec4(intersectionPoint, 1.f) * _transform;
intersectionPoint = glm::vec3(homoIntersectionPoint[0], homoIntersectionPoint[1], homoIntersectionPoint[2]);
-

== Apply inverse transform to norm ==
-
glm::vec4 homoNorm = glm::vec4(norm, 0.f) * glm::transpose(_inverseTransform);
norm = glm::normalize(glm::vec3(homoNorm[0], homoNorm[1], homoNorm[2]));
-

== Get bounding box ==
Apply the transformation on this object and return
a new bounding box.
-
BoundingBox TriMesh::GetBoundingBox() {
  glm::vec4 min = glm::vec4(_bb->GetMin(), 1.f);
  glm::vec4 max = glm::vec4(_bb->GetMax(), 1.f);
  glm::vec4 tMin = min * _transform;
  glm::vec4 tMax = max * _transform;
  glm::vec3 finalMin = glm::vec3(
    std::min(tMin[0], tMax[0]), std::min(tMin[1], tMax[1]), std::min(tMin[2], tMax[2])
  );
  glm::vec3 finalMax = glm::vec3(
    std::max(tMin[0], tMax[0]), std::max(tMin[1], tMax[1]), std::max(tMin[2], tMax[2])
  );
  return BoundingBox(glm::vec3(finalMin[0], finalMin[1], finalMin[2]), glm::vec3(finalMax[0], finalMax[1], finalMax[2]));
}
-

== Includes ==
-
#include <iostream>
#include "TriMesh.hpp"
-

== Wrapper ==
-
Includes.

Add vertex.

Add triangle.

Intersection.

Get bounding box.
-

== @TriMesh.cpp ==
Wrapper.
